{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/using-record-to-dto/","result":{"data":{"site":{"siteMetadata":{"title":"Wan.log","siteUrl":"https://wwan13.github.io","thumbnail":"/thumbnails/tech-blog-thumbnail.png"}},"markdownRemark":{"id":"2d42acf0-d341-59f4-9b33-55eb9c9130e4","tableOfContents":"<ul>\n<li><a href=\"#immutable-%ED%95%9C-dto\">Immutable 한 DTO</a></li>\n<li><a href=\"#record%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-immutable%ED%95%9C-dto-%EB%A7%8C%EB%93%A4%EA%B8%B0\">Record를 이용해 \bImmutable한 DTO 만들기</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","excerpt":"…","html":"<p>객체를 <code class=\"language-text\">Immutable</code> 하게 생성 하는 것으로 많은 장점을 가지게 됩니다.</p>\n<p>한 번 생성 된 불변 객체는 그 값이 변하지 않기 때문에 우리는 이 객체에 더욱 신뢰할 수 있습니다. 또 멀티 쓰레드 환경에서 동기화 처리 없이 객체를 공유할 수 있다는 것도 하나의 장점입니다.</p>\n<p>그리고 저는 <code class=\"language-text\">DTO</code>, <code class=\"language-text\">VO</code>는 더더욱 불변으로 관리해야 한다고 생각하였습니다. 계층간 전달해야 할 값이 setter에 의해 변경 된다거나, properties와 같이 환경 변수 등의 변해선 안되는 값이 setter에 의해 언제든 변경될 수 있다면 그 값에 대한 신뢰가 떨어지기 마련입니다.</p>\n<p>하지만, 일반적인 상황에서 Spring의 모든 DTO를 \bImmutable 하게 관리 하기엔 꽤 많은 비용이 소모됩니다.</p>\n<br>\n<br>\n<h2 id=\"immutable-한-dto\" style=\"position:relative;\">Immutable 한 DTO<a href=\"#immutable-%ED%95%9C-dto\" aria-label=\"immutable 한 dto permalink\" class=\"heading-anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>저는 Immutable 한 DTO를 만들기 위해 다음과 같은 코드를 작성하기로 하였습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token annotation punctuation\">@RequireArgsConstructor</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberDto</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 DTO를 직렬화 즉 ResponseBody에 담아서 응답으로 보내주는 것에는 큰 문제 없습니다.</p>\n<p>하지만 이 DTO를 RequestBody로 받는 API에서는 다음과 같은 문제가 발생하게 됩니다.</p>\n<p><img src=\"https://github.com/wwan13/wwan13.github.io/assets/64270501/cb6edc01-bce4-4a58-9c7b-e0d8e23a1ddf\" alt=\"실패 요청 결과\"></p>\n<p>그 원인은 <code class=\"language-text\">ObjectMapper</code>의 역직렬화 방법에 있습니다.</p>\n<p>ObjectMapper는 다음과 같은 방법으로 JSON 역직렬화를 수행합니다.</p>\n<ol>\n<li><code class=\"language-text\">BeanDeserializer.deserializeFromObject()</code> 에서 기본 생성자를 이용한 리플렉션으로 DTO 객체를 생성합니다.</li>\n<li><code class=\"language-text\">FieldProperty.deserializeAndSet(...)</code> 에서 리플렉선으로 얻어온 Filed에 JSON에서 얻은 값을 set 합니다.</li>\n</ol>\n<p>여기서 문제는 2번의 set입니다. 우리는 DTO의 모든 필드를 final로 선언하였기 때문에 set 과정을 수행할 수 없는 것입니다.</p>\n<br>\n<p>그래서 저는 일반적으로 다음과 같은 DTO를 작성하곤 했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token annotation punctuation\">@NoArgsConstructor</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberDto</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>필드를 final로 선언하지 않고, 기본 생성자와 getter를 가지고 있는 모습 입니다.</p>\n<p>이렇게 선언하면 다음과 같이 성공적으로 API를 호출 할 수 있게 됩니다.</p>\n<p><img src=\"https://github.com/wwan13/wwan13.github.io/assets/64270501/1b4a1473-5075-4f93-8ec1-4e255e6ce5e9\" alt=\"성공 요청 결과\"></p>\n<br>\n<p>하지만 저의 관심사는 성공하는 DTO를 만드는게 아니라, \bImmutable한 DTO를 만드는 것입니다.\n이 것을 <code class=\"language-text\">@JsonProperty</code>와 <code class=\"language-text\">@JsonCreator</code> 라는 어노테이션을 통해 다음과 같이 해결할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberDto</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token annotation punctuation\">@JsonPropertiey</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token annotation punctuation\">@JsonPropertiey</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"age\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@JsonCreator</span><span class=\"token punctuation\">(</span>mode <span class=\"token operator\">=</span> <span class=\"token class-name\">JsonCreator<span class=\"token punctuation\">.</span>Mode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PROPERTIES</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">MemberDto</span><span class=\"token punctuation\">(</span>\n\t\t<span class=\"token annotation punctuation\">@JsonPropertiey</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span>\n\t\t<span class=\"token annotation punctuation\">@JsonPropertiey</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"age\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">int</span> age\n\t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>우리는 이렇게 Immutable한 DTO를 얻을 수 있게 되었습니다.\n하지만 추가로 작성해야 하는 어노테이션이 너무 많습니다. API 가 요청하는 필드가 많아지면 많아질 수록 더 많은 어노테이션을 작성해야 합니다.</p>\n<br>\n<br>\n<h2 id=\"record를-이용해-immutable한-dto-만들기\" style=\"position:relative;\">Record를 이용해 \bImmutable한 DTO 만들기<a href=\"#record%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-immutable%ED%95%9C-dto-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"record를 이용해 immutable한 dto 만들기 permalink\" class=\"heading-anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">Record</code>는 Java 14 에서 추가된 클래스로 <strong>필드 유형과 이름만 필요한 불변 데이터 클래스</strong> 입니다.\n(Record에 대한 자세한 셜명은 <a href=\"https://www.baeldung.com/java-record-keyword\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">baeldung</a>에 잘 정리가 되어 있으니 이 글을 참고시면 됩니다.)</p>\n<p>Record를 이용하면 위 예시를 다음과 같이 간단하게 선언할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">record</span> <span class=\"token class-name\">MemberDto</span><span class=\"token punctuation\">(</span>\n\t\t<span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> \n\t\t<span class=\"token keyword\">int</span> age\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한 특별한 어노테이션 없이 ObjectMapper를 통한 직렬화, 역직렬화를 수행할 수 있습니다.</p>\n<p><img src=\"https://github.com/wwan13/wwan13.github.io/assets/64270501/bd74c519-2bf6-40c6-80dc-259d897b84e3\" alt=\"record test\"></p>\n<p><img src=\"https://github.com/wwan13/wwan13.github.io/assets/64270501/3fac391a-efa9-41d2-94be-f6d859499645\" alt=\"record test 결과\"></p>\n<p>테스트를 통해 확인해 보면 문제 없이 역직렬화를 수행하는 것을 볼 수 있습니다.</p>\n<p><img src=\"https://github.com/wwan13/wwan13.github.io/assets/64270501/1b4a1473-5075-4f93-8ec1-4e255e6ce5e9\" alt=\"성공 요청 결과\"></p>\n<p>당연하게 API도 문제 없이 호출 됩니다.</p>\n<br>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"heading-anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇게 <code class=\"language-text\">Record</code>를 이용해 <code class=\"language-text\">DTO</code>를 조금 더 쉽게 <code class=\"language-text\">Immutable</code>한 상태로 관리할 수 있게 되었습니다.</p>\n<p>Record는 기존의 class DTO와 달리 getter나 기본 생성자 등을 추가로 구현하지 않아도 DTO로서의  동작을 수행 하기 때문에 개발자의 실수를 줄일 수 있다는 장점도 존재 합니다.\n(실제로 실수로 기본 생성자를 빼먹어 삽질을 한 경우가 수 없이 존재한다..)</p>\n<p><code class=\"language-text\">Lazy Loading</code>의 동작 방법 때문에 Record가 <code class=\"language-text\">Entity</code>로는 사용하지 못하지만, DTO 혹은 VO로 사용 하기엔 적합한 클래스 인 것 같아 앞으로도 유용하게 사용할 것 같습니다.</p>","fields":{"slug":"/using-record-to-dto/"},"frontmatter":{"title":"Record를 DTO로 사용해 보자","date":"2024-01-27","description":"Java의 Record를 이용하여 DTO를 보다 Immutable하게 관리 하는 법을 알아보자.","tags":["Tech"],"thumbnail":null}},"previous":null,"next":{"fields":{"slug":"/without-spring-security/"},"frontmatter":{"title":"Spring Security 없이 JWT 인증/인가 구현 해보기"}}},"pageContext":{"id":"2d42acf0-d341-59f4-9b33-55eb9c9130e4","previousPostId":null,"nextPostId":"4d89736e-6e9e-53a6-8939-d21b655b1ee5"}},"staticQueryHashes":["2260143708","2538111481","658623446","984448874"]}